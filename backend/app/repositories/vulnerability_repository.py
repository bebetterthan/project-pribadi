"""
Vulnerability Repository - Operations for vulnerability management
"""
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import desc, func, and_, or_
from app.models import Vulnerability, VulnerabilitySeverity, VulnerabilityStatus
from app.repositories.base import BaseRepository


class VulnerabilityRepository(BaseRepository[Vulnerability]):
    """Repository for Vulnerability operations"""
    
    def __init__(self, db: Session):
        super().__init__(Vulnerability, db)
    
    def get_scan_vulnerabilities(
        self,
        scan_id: str,
        severity: Optional[VulnerabilitySeverity] = None,
        status: Optional[VulnerabilityStatus] = None,
        skip: int = 0,
        limit: int = 100
    ) -> List[Vulnerability]:
        """Get vulnerabilities for a specific scan"""
        query = self.db.query(Vulnerability).filter(Vulnerability.scan_id == scan_id)
        
        if severity:
            query = query.filter(Vulnerability.severity == severity)
        
        if status:
            query = query.filter(Vulnerability.status == status)
        
        # Order by severity and CVSS score
        return (
            query.order_by(
                desc(Vulnerability.severity),
                desc(Vulnerability.cvss_score)
            )
            .offset(skip)
            .limit(limit)
            .all()
        )
    
    def get_by_cve(self, cve_id: str) -> List[Vulnerability]:
        """Get all vulnerabilities with specific CVE"""
        return (
            self.db.query(Vulnerability)
            .filter(Vulnerability.cve_id == cve_id)
            .order_by(desc(Vulnerability.discovered_at))
            .all()
        )
    
    def get_host_vulnerabilities(
        self,
        host: str,
        status: Optional[VulnerabilityStatus] = None
    ) -> List[Vulnerability]:
        """Get all vulnerabilities for a specific host"""
        query = self.db.query(Vulnerability).filter(Vulnerability.affected_host == host)
        
        if status:
            query = query.filter(Vulnerability.status == status)
        
        return query.order_by(desc(Vulnerability.severity), desc(Vulnerability.cvss_score)).all()
    
    def count_by_severity(self, scan_id: str) -> Dict[str, int]:
        """Count vulnerabilities by severity for a scan"""
        results = (
            self.db.query(
                Vulnerability.severity,
                func.count(Vulnerability.id).label('count')
            )
            .filter(Vulnerability.scan_id == scan_id)
            .group_by(Vulnerability.severity)
            .all()
        )
        
        counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0,
        }
        
        for severity, count in results:
            counts[severity.value] = count
        
        return counts
    
    def update_status(
        self,
        vuln_id: str,
        status: VulnerabilityStatus,
        assigned_to: Optional[str] = None,
        notes: Optional[str] = None
    ) -> Optional[Vulnerability]:
        """Update vulnerability status"""
        vuln = self.get(vuln_id)
        if not vuln:
            return None
        
        vuln.status = status
        
        if assigned_to is not None:
            vuln.assigned_to = assigned_to
        
        if notes is not None:
            vuln.notes = notes
        
        # Update timestamps
        from datetime import datetime
        if status == VulnerabilityStatus.ACKNOWLEDGED and not vuln.acknowledged_at:
            vuln.acknowledged_at = datetime.utcnow()
        elif status == VulnerabilityStatus.FIXED and not vuln.fixed_at:
            vuln.fixed_at = datetime.utcnow()
        
        self.db.commit()
        self.db.refresh(vuln)
        return vuln
    
    def search(self, search_term: str, limit: int = 50) -> List[Vulnerability]:
        """Search vulnerabilities by title, description, or CVE"""
        search_pattern = f"%{search_term}%"
        return (
            self.db.query(Vulnerability)
            .filter(
                or_(
                    Vulnerability.title.ilike(search_pattern),
                    Vulnerability.description.ilike(search_pattern),
                    Vulnerability.cve_id.ilike(search_pattern)
                )
            )
            .order_by(desc(Vulnerability.severity), desc(Vulnerability.discovered_at))
            .limit(limit)
            .all()
        )
    
    def get_statistics(self, scan_id: Optional[str] = None) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        query = self.db.query(Vulnerability)
        
        if scan_id:
            query = query.filter(Vulnerability.scan_id == scan_id)
        
        total = query.count()
        
        by_severity = self.count_by_severity(scan_id) if scan_id else {}
        
        by_status = (
            self.db.query(
                Vulnerability.status,
                func.count(Vulnerability.id).label('count')
            )
            .group_by(Vulnerability.status)
        )
        
        if scan_id:
            by_status = by_status.filter(Vulnerability.scan_id == scan_id)
        
        status_counts = {status.value: 0 for status in VulnerabilityStatus}
        for status, count in by_status.all():
            status_counts[status.value] = count
        
        # Count with exploits
        with_exploit = query.filter(Vulnerability.exploit_available == True).count()
        
        return {
            "total": total,
            "by_severity": by_severity,
            "by_status": status_counts,
            "with_exploit": with_exploit,
            "without_patch": query.filter(Vulnerability.patch_available == False).count(),
        }

