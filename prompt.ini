üìã EXECUTIVE SUMMARY
Bangun sebuah AI Pentest Agent MVP yang fokus pada lightweight pentesting tools untuk development dan testing di localhost. Platform ini mengintegrasikan tools ringan (Nmap, Nuclei, whatweb, sslscan) dengan AI analysis (Google Gemini) untuk automated reconnaissance.

Fokus MVP: Simplicity, speed to market, extensibility untuk future heavy tools (OWASP ZAP, sqlmap, Burp Suite).

Timeline Target: 1-2 minggu untuk working prototype

üèóÔ∏è SIMPLIFIED ARCHITECTURE
Architecture Type
Monolithic for MVP: Backend dan Frontend dalam satu repo, simple deployment
Synchronous First: No Celery untuk MVP (add later when needed)
SQLite Database: Zero configuration, file-based database
Single User Mode: No authentication untuk localhost development
Deployment Model
Phase 1 (Current Focus): Localhost only, accessible via http://localhost:3000
Future Phase: Migration ke async (Celery) + deployment ke GCP
üíª TECHNOLOGY STACK (LIGHTWEIGHT FOCUS)
BACKEND: Python + FastAPI
Minimal Dependencies (requirements.txt):
plaintext
Core Framework:
- fastapi==0.104.1
- uvicorn[standard]==0.24.0
- python-multipart==0.0.6

Data & Validation:
- pydantic==2.5.0
- pydantic-settings==2.1.0
- python-dotenv==1.0.0

Database (SQLite):
- sqlalchemy==2.0.23
- alembic==1.13.0

Security:
- validators==0.22.0
- python-jose[cryptography]==3.3.0 (optional untuk future auth)

AI Integration:
- google-generativeai==0.3.1

Tool Integration (Lightweight):
- python-nmap==0.7.1 (Nmap parser)
- xmltodict==0.13.0 (parse XML output)
- requests==2.31.0 (HTTP requests untuk API calls)

Utilities:
- loguru==0.7.2 (logging)
Total Dependencies: ~15 packages (very manageable)

Notable EXCLUSIONS for MVP:

‚ùå Celery (no background jobs yet, synchronous execution)
‚ùå Redis (tidak perlu tanpa Celery)
‚ùå PostgreSQL (pakai SQLite dulu)
‚ùå python-owasp-zap (ZAP untuk future phase)
‚ùå WebSocket libraries (no real-time updates untuk MVP)
FRONTEND: Next.js 14 + TypeScript
Minimal Dependencies (package.json):
JSON
Core Framework:
- next: ^14.0.4
- react: ^18.2.0
- react-dom: ^18.2.0
- typescript: ^5.3.0

State Management (Simple):
- zustand: ^4.4.7

Data Fetching:
- @tanstack/react-query: ^5.14.0
- axios: ^1.6.2

UI & Styling:
- tailwindcss: ^3.4.0
- @headlessui/ui: ^1.7.17 (unstyled accessible components)
- lucide-react: ^0.294.0 (icons)
- clsx: ^2.0.0 (className utility)

Form Handling:
- react-hook-form: ^7.48.0
- zod: ^3.22.4

Display & Formatting:
- react-markdown: ^9.0.1 (display AI analysis)
- react-syntax-highlighter: ^15.5.0 (syntax highlighting)
- date-fns: ^3.0.0
Total Dependencies: ~20 packages (lean frontend)

Notable EXCLUSIONS:

‚ùå Socket.io (no WebSocket untuk MVP)
‚ùå Chart libraries (visualization untuk future)
‚ùå Heavy UI frameworks (MUI, Ant Design)
üîß LIGHTWEIGHT TOOLS SELECTION
Tools Included in MVP:
1. Nmap (Network Scanner)
Why Included:

‚úÖ Fundamental tool, must-have untuk pentesting
‚úÖ Fast execution (30 seconds - 2 minutes untuk basic scan)
‚úÖ Low resource usage (~50-100 MB RAM)
‚úÖ Rich output (ports, services, versions, OS detection)
Scan Profiles for MVP:

Quick: nmap -F -sV <target> (top 100 ports, version detection)
Normal: nmap -sV -sC <target> (default ports, version + default scripts)
Aggressive: nmap -A -T4 <target> (OS detection, traceroute, aggressive timing)
Output Format: XML (-oX -) untuk easy parsing dengan python-nmap

2. Nuclei (Vulnerability Scanner)
Why Included:

‚úÖ Template-based scanning (10,000+ vulnerability templates)
‚úÖ Fast dan efficient (concurrent requests)
‚úÖ Low resource (~200-300 MB RAM)
‚úÖ JSON output (easy parsing)
‚úÖ Regularly updated templates (community-driven)
Scan Profiles for MVP:

Quick: nuclei -u <target> -severity critical -json (critical only)
Normal: nuclei -u <target> -severity high,critical -json
Aggressive: nuclei -u <target> -severity medium,high,critical -json
Template Categories: CVE, Exposures, Misconfigurations, Default credentials

Installation: go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest

3. whatweb (Web Technology Identifier)
Why Included:

‚úÖ Extremely lightweight (~10 MB RAM)
‚úÖ Super fast (2-5 seconds)
‚úÖ Identify CMS, frameworks, server software
‚úÖ JSON output available
Usage: whatweb --log-json=- <target>

What It Detects:

CMS (WordPress, Joomla, Drupal)
Programming languages (PHP, Python, Node.js)
Web servers (Apache, Nginx, IIS)
JavaScript libraries (jQuery, React, Angular)
Cookies, headers, meta tags
Value for Pentest: Knowing tech stack helps prioritize attack vectors

4. sslscan (SSL/TLS Scanner)
Why Included:

‚úÖ Very lightweight (~20 MB RAM)
‚úÖ Fast execution (5-10 seconds)
‚úÖ Critical untuk HTTPS targets
‚úÖ Detect SSL/TLS vulnerabilities (Heartbleed, POODLE, weak ciphers)
Usage: sslscan --xml=- <target>

What It Checks:

Supported SSL/TLS versions
Cipher suites (strong vs weak)
Certificate validity and chain
Known vulnerabilities (Heartbleed, POODLE, CRIME, BEAST)
Installation: apt install sslscan (Linux) atau compile from source

Tools EXCLUDED from MVP (Future Phase):
Heavy Tools (Add Later When Needed):
‚è≠Ô∏è OWASP ZAP (4-6 GB RAM, Java-based, slow startup)
‚è≠Ô∏è sqlmap (Resource intensive untuk large parameter testing)
‚è≠Ô∏è Burp Suite (4-8 GB RAM, complex integration)
‚è≠Ô∏è Metasploit (2-4 GB RAM dengan database, overkill untuk MVP)
Nice-to-Have Tools (Extension Phase):
‚è≠Ô∏è Nikto (web server scanner, banyak false positives)
‚è≠Ô∏è Gobuster/ffuf (directory bruteforce, bisa lama)
‚è≠Ô∏è Amass (subdomain enumeration, time-consuming)
‚è≠Ô∏è Wappalyzer CLI (similar dengan whatweb, redundant)
Rationale: MVP fokus pada tools yang:

Execute cepat (< 5 menit per tool)
Low resource usage (< 500 MB RAM per tool)
High signal-to-noise ratio (actionable results)
Essential untuk reconnaissance phase
üìÅ PROJECT STRUCTURE (SIMPLIFIED)
Root Directory:
Code
ai-pentest-agent/
‚îú‚îÄ‚îÄ backend/                    # Python FastAPI
‚îú‚îÄ‚îÄ frontend/                   # Next.js
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ docker-compose.yml         # Optional (untuk future)
Backend Structure (Simplified):
Code
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                     # FastAPI app entry point
‚îÇ   ‚îú‚îÄ‚îÄ config.py                   # Settings (pydantic-settings)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ endpoints/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ scan.py         # POST /scan, GET /scan/{id}
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ analysis.py     # POST /analysis/{scan_id}
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ history.py      # GET /scans (list all)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ router.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py               # App configuration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exceptions.py           # Custom exceptions
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scanner_service.py      # Orchestrate tool execution
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai_service.py           # Gemini integration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation_service.py   # Input sanitization
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ tools/                      # Tool wrappers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py                 # Abstract base tool class
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nmap_tool.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nuclei_tool.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ whatweb_tool.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sslscan_tool.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ factory.py              # Tool factory
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/                     # SQLAlchemy models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scan.py                 # Scan model
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ result.py               # ScanResult model
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ analysis.py             # AIAnalysis model
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ schemas/                    # Pydantic schemas (API contracts)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scan.py                 # ScanCreate, ScanResponse
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ result.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ analysis.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py                 # SQLAlchemy declarative base
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py              # Database session
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ init_db.py              # Database initialization
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ logger.py               # Loguru config
‚îÇ       ‚îú‚îÄ‚îÄ parsers.py              # Tool output parsers
‚îÇ       ‚îî‚îÄ‚îÄ sanitizers.py           # Input sanitization
‚îÇ
‚îú‚îÄ‚îÄ alembic/                        # Database migrations
‚îÇ   ‚îú‚îÄ‚îÄ versions/
‚îÇ   ‚îî‚îÄ‚îÄ env.py
‚îÇ
‚îú‚îÄ‚îÄ tests/                          # Tests (optional untuk MVP)
‚îÇ   ‚îî‚îÄ‚îÄ test_tools.py
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt                # Python dependencies
‚îú‚îÄ‚îÄ .env.example                    # Environment variables template
‚îú‚îÄ‚îÄ alembic.ini                     # Alembic config
‚îî‚îÄ‚îÄ pentest.db                      # SQLite database (generated)
Key Simplifications:

‚ùå No workers/ folder (no Celery)
‚ùå No complex auth system (single user, localhost only)
‚úÖ Flat structure, easy to navigate
‚úÖ Clear separation of concerns (API ‚Üí Service ‚Üí Tool)
Frontend Structure (Simplified):
Code
frontend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/                        # Next.js App Router
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx              # Root layout
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                # Home (Dashboard)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scan/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx            # New scan form
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [id]/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx        # Scan detail/results
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ history/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx            # Scan history
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/                     # Base components
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Card.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Badge.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Header.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scan/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ScanForm.tsx        # Target input + tool selector
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ScanStatus.tsx      # Status badge (pending/running/completed)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ScanResults.tsx     # Display tool results
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ analysis/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ AnalysisDisplay.tsx # Render AI markdown output
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts                  # Axios instance + API client
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants.ts            # App constants
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts                # Helper functions
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useScans.ts             # React Query hooks
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useStore.ts             # Zustand store (API key, settings)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts                  # API types
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scan.ts                 # Scan types
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ       ‚îî‚îÄ‚îÄ globals.css             # Tailwind imports
‚îÇ
‚îú‚îÄ‚îÄ public/                         # Static assets
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ next.config.js
‚îî‚îÄ‚îÄ .env.local.example              # Frontend env vars
Key Simplifications:

‚ùå No WebSocket hooks (no real-time updates untuk MVP)
‚ùå No chart/visualization components (future phase)
‚ùå No settings page (API key input di scan form directly)
‚úÖ Minimal components, fast development
‚úÖ Easy to extend later
üîÑ USER WORKFLOW (MVP)
Happy Path: Complete Scan Flow
Step 1: User Opens App

Navigate to http://localhost:3000
See dashboard with "Start New Scan" button
(Optional) View recent scans table (if any exist)
Step 2: Configure Scan

Click "Start New Scan" ‚Üí navigate to /scan
Input Fields:
Target: Text input (domain, subdomain, IP, atau URL)
Example: example.com, https://example.com, 192.168.1.1
Real-time validation: ‚úÖ Valid atau ‚ùå Invalid
Gemini API Key: Password input (show/hide toggle)
Placeholder: "Enter your Google Gemini API key"
Optional checkbox: "Remember for this session" (store in memory only)
Tool Selection: Checkboxes (default: all selected)
‚òëÔ∏è Nmap (Port Scan)
‚òëÔ∏è Nuclei (Vulnerability Scan)
‚òëÔ∏è whatweb (Tech Detection)
‚òëÔ∏è sslscan (SSL/TLS Scan) - auto-disable if target is HTTP only
Scan Profile: Dropdown
Quick (2-3 minutes)
Normal (5-7 minutes) - default
Aggressive (10-15 minutes)
Enable AI Analysis: Toggle (default: ON)
Click "Start Scan" button
Step 3: Scan Execution (Backend)

Frontend send POST request ke /api/v1/scan
Backend:
Validate input (sanitize target, validate API key format)
Create Scan record in database (status: PENDING)
Return scan_id immediately ke frontend
Status ‚Üí RUNNING
Execute tools sequentially:
Run Nmap ‚Üí parse output ‚Üí save ScanResult
Run Nuclei ‚Üí parse output ‚Üí save ScanResult
Run whatweb ‚Üí parse output ‚Üí save ScanResult
Run sslscan (if applicable) ‚Üí parse output ‚Üí save ScanResult
Status ‚Üí COMPLETED (atau FAILED jika error)
If AI enabled: Call Gemini API dengan aggregated results ‚Üí save AIAnalysis
Step 4: Display Results (Frontend)

After submit, frontend redirect ke /scan/{scan_id}
Loading State:
Show spinner dengan text: "Scan in progress..."
Polling: Frontend poll GET /api/v1/scan/{scan_id} setiap 3 seconds
Display status: "Running Nmap..." (backend return current_tool info)
Completed State:
Display 2 tabs:
Tab 1: AI Analysis (default active)
Markdown rendering dari AI output
Sections: Executive Summary, Critical Findings, Recommendations
Syntax highlighted code blocks (exploit commands)
Tab 2: Tool Results
Accordion per tool (expandable)
Raw output dengan syntax highlighting
Metadata: Execution time, exit code
Action buttons:
"Run Another Scan" ‚Üí back to /scan
"View History" ‚Üí navigate to /history
Step 5: History Management

Navigate to /history
Table columns:
Target
Tools Used (badges: Nmap, Nuclei, etc.)
Status (badge with color)
Started At (formatted date)
Duration
Actions: "View" (‚Üí detail page), "Delete" (with confirmation)
Pagination: 20 scans per page
Simple search: Filter by target name
üîê SECURITY IMPLEMENTATION (ESSENTIAL FOR MVP)
1. Input Validation & Sanitization
Target Validation Service:
Validation Rules:

Format Check:

Domain: example.com (regex: ^[a-z0-9]([a-z0-9\-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9\-]{0,61}[a-z0-9])?)*$)
IP: 192.168.1.1 (use validators.ipv4() atau validators.ipv6())
URL: https://example.com/path (use validators.url())
Sanitization:

Strip leading/trailing whitespace
Lowercase untuk domain
Remove protocol untuk domain (https://example.com ‚Üí example.com)
URL-decode untuk detect encoded injection attempts
Blacklist Check:

Python
BLACKLISTED_NETWORKS = [
    '127.0.0.0/8',      # Localhost
    '10.0.0.0/8',       # Private
    '172.16.0.0/12',    # Private
    '192.168.0.0/16',   # Private
    '169.254.0.0/16',   # Link-local
    '0.0.0.0/8',        # Invalid
    '224.0.0.0/4',      # Multicast
]
Resolve domain ke IP dengan socket.gethostbyname()
Check if IP in blacklisted ranges dengan ipaddress module
Reject jika blacklisted
Special Character Check:

Reject jika contain: ;, |, &, $, `, \n, \r, (, ), <, >
Rationale: Prevent command injection
Implementation Location: app/services/validation_service.py

Command Execution Safety:
NEVER DO THIS (Vulnerable):

Python
# ‚ùå DANGEROUS - Command Injection Vulnerability
os.system(f"nmap -sV {target}")
subprocess.run(f"nmap -sV {target}", shell=True)
ALWAYS DO THIS (Safe):

Python
# ‚úÖ SAFE - No shell interpolation
subprocess.run(['nmap', '-sV', sanitized_target],
               capture_output=True,
               text=True,
               timeout=300,
               check=False)  # Don't raise exception on non-zero exit
Tool Execution Pattern (All Tools):

Python
class NmapTool(BaseTool):
    def execute(self, target: str, options: dict) -> ToolResult:
        # Build command as list
        cmd = ['nmap', '-sV', '-oX', '-', target]

        # Execute safely
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=self.timeout,
            shell=False  # CRITICAL: Never use shell=True
        )

        return ToolResult(
            tool_name='nmap',
            exit_code=result.returncode,
            stdout=result.stdout,
            stderr=result.stderr,
            execution_time=...,
        )
2. API Key Handling (Zero Persistence)
Frontend Strategy:
Option A: In-Memory Only (Most Secure for MVP):

TypeScript
// Zustand store
interface AppStore {
  geminiApiKey: string | null;
  setGeminiApiKey: (key: string) => void;
  clearGeminiApiKey: () => void;
}

// User enter key ‚Üí store in Zustand
// Send key dalam HTTP header ke backend
// On browser refresh ‚Üí key lost (user must re-enter)
API Call Pattern:

TypeScript
// lib/api.ts
const submitScan = async (target: string, apiKey: string) => {
  return axios.post('/api/v1/scan',
    { target, tools: ['nmap', 'nuclei'], profile: 'normal' },
    { headers: { 'X-Gemini-API-Key': apiKey } }
  );
};
Option B: sessionStorage (Persists in Tab):

TypeScript
// Persist selama tab open, hilang kalau tab closed
sessionStorage.setItem('gemini_key', apiKey);
const key = sessionStorage.getItem('gemini_key');
Backend Handling:

Python
# Extract key dari header
def get_gemini_key(request: Request) -> str:
    key = request.headers.get('X-Gemini-API-Key')
    if not key:
        raise HTTPException(400, "Gemini API key required")
    return key

# Use key dalam function scope only
@router.post('/scan')
async def create_scan(data: ScanCreate,
                      gemini_key: str = Depends(get_gemini_key)):
    # gemini_key hanya ada di function scope
    # Tidak disimpan ke database
    # Garbage collected setelah response
    ai_service = AIService(api_key=gemini_key)
    analysis = ai_service.analyze(...)
    return response
CRITICAL RULES:

‚ùå NEVER save API key to database
‚ùå NEVER log API key (mask di logger)
‚ùå NEVER return API key dalam API response
‚úÖ Use key only within request scope
‚úÖ Clear key dari memory after use (Python garbage collection handle ini)
3. Error Handling & Logging
Logging Strategy:
What to Log:

‚úÖ Scan requests: target, tools, timestamp, execution time
‚úÖ Tool execution: command, exit code, execution duration
‚úÖ Errors: tool failures, validation errors, API errors
‚úÖ AI usage: tokens consumed, cost estimate
What NOT to Log:

‚ùå API keys (mask dengan ***)
‚ùå Raw tool output yang sensitive (password leaks, API keys dari target)
‚ùå User credentials (kalau nanti ada auth)
Loguru Configuration:

Python
# app/utils/logger.py
from loguru import logger
import sys

# Remove default handler
logger.remove()

# Console output (development)
logger.add(
    sys.stdout,
    level="INFO",
    format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>"
)

# File output (production)
logger.add(
    "logs/app.log",
    rotation="100 MB",  # Rotate when file reach 100MB
    retention="30 days",  # Keep logs for 30 days
    compression="zip",
    level="INFO"
)

# Sensitive data masking
def mask_api_key(key: str) -> str:
    if len(key) < 8:
        return "***"
    return f"{key[:4]}...{key[-4:]}"
Usage:

Python
from app.utils.logger import logger

# Good logging
logger.info(f"Scan started: target={target}, tools={tools}")
logger.info(f"Nmap completed in {duration}s, found {port_count} open ports")
logger.error(f"Tool failed: {tool_name}, exit_code={exit_code}")

# API key masking
logger.debug(f"Using API key: {mask_api_key(api_key)}")
ü§ñ AI INTEGRATION (GOOGLE GEMINI)
AI Service Design
Service Class Structure:
Python
# app/services/ai_service.py
import google.generativeai as genai
from typing import Dict, List

class AIService:
    def __init__(self, api_key: str):
        self.api_key = api_key
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-1.5-flash-002')

    def analyze_scan_results(self, scan_data: Dict) -> AIAnalysisResult:
        """
        Analyze aggregated scan results and generate insights
        """
        # Build prompt
        prompt = self._build_analysis_prompt(scan_data)

        # Call Gemini API
        response = self.model.generate_content(
            prompt,
            generation_config={
                'temperature': 0.2,  # Low temp for analytical tasks
                'max_output_tokens': 4096,
            }
        )

        # Extract token usage
        usage = response.usage_metadata

        return AIAnalysisResult(
            analysis_text=response.text,
            prompt_tokens=usage.prompt_token_count,
            completion_tokens=usage.candidates_token_count,
            model_used='gemini-1.5-flash-002',
        )

    def _build_analysis_prompt(self, scan_data: Dict) -> str:
        """Build comprehensive prompt dari scan results"""
        # Implementation below
Prompt Engineering (Critical for Quality)
System Context:
Python
SYSTEM_CONTEXT = """
You are an expert penetration tester and security analyst with 15+ years of experience in offensive security, vulnerability assessment, and exploit development.

Your analysis style:
- Prioritize findings by EXPLOITABILITY (not just severity scores)
- Provide SPECIFIC exploitation techniques with exact commands
- Identify false positives and explain reasoning
- Reference CVE IDs, CVSS scores, and MITRE ATT&CK techniques
- Be concise but actionable (no fluff)

Target audience: Professional penetration testers who need actionable intel, not generic advice.
"""
Dynamic Prompt Template:
Python
def _build_analysis_prompt(self, scan_data: Dict) -> str:
    target = scan_data['target']
    tools = scan_data['tools']

    # Start with system context
    prompt = SYSTEM_CONTEXT + "\n\n"

    prompt += f"# Penetration Test Analysis\n\n"
    prompt += f"**Target:** {target}\n"
    prompt += f"**Scan Date:** {scan_data['timestamp']}\n"
    prompt += f"**Tools Used:** {', '.join(tools)}\n\n"

    # Add Nmap results
    if 'nmap' in scan_data['results']:
        nmap = scan_data['results']['nmap']
        prompt += "## Nmap Scan Results\n\n"
        prompt += f"**Open Ports:** {len(nmap['open_ports'])}\n\n"

        # Format port details
        for port in nmap['open_ports']:
            prompt += f"- **Port {port['port']}/{port['protocol']}**: "
            prompt += f"{port['service']} {port['version']}\n"

        if nmap.get('os_detection'):
            prompt += f"\n**OS Detection:** {nmap['os_detection']}\n"

        prompt += "\n"

    # Add Nuclei results
    if 'nuclei' in scan_data['results']:
        nuclei = scan_data['results']['nuclei']
        prompt += "## Nuclei Vulnerability Scan\n\n"

        if nuclei['findings']:
            prompt += f"**Vulnerabilities Found:** {len(nuclei['findings'])}\n\n"
            for finding in nuclei['findings']:
                prompt += f"### {finding['template_id']}\n"
                prompt += f"- **Severity:** {finding['severity']}\n"
                prompt += f"- **Matched At:** {finding['matched_at']}\n"
                if finding.get('cve_id'):
                    prompt += f"- **CVE:** {finding['cve_id']}\n"
                prompt += f"- **Description:** {finding['info']}\n\n"
        else:
            prompt += "No vulnerabilities detected by Nuclei templates.\n\n"

    # Add whatweb results
    if 'whatweb' in scan_data['results']:
        whatweb = scan_data['results']['whatweb']
        prompt += "## Technology Stack (whatweb)\n\n"
        prompt += f"- **Web Server:** {whatweb.get('server', 'Unknown')}\n"
        prompt += f"- **CMS:** {whatweb.get('cms', 'Not detected')}\n"
        prompt += f"- **Programming Language:** {whatweb.get('language', 'Unknown')}\n"
        prompt += f"- **JavaScript Frameworks:** {', '.join(whatweb.get('js_frameworks', []))}\n\n"

    # Add sslscan results
    if 'sslscan' in scan_data['results']:
        sslscan = scan_data['results']['sslscan']
        prompt += "## SSL/TLS Analysis (sslscan)\n\n"
        prompt += f"- **Certificate Valid:** {sslscan.get('cert_valid', 'N/A')}\n"
        prompt += f"- **Weak Ciphers:** {len(sslscan.get('weak_ciphers', []))}\n"
        if sslscan.get('vulnerabilities'):
            prompt += f"- **Known Vulnerabilities:** {', '.join(sslscan['vulnerabilities'])}\n"
        prompt += "\n"

    # Analysis instructions
    prompt += """
# Analysis Request

Based on the scan results above, provide a comprehensive penetration testing analysis with the following structure:

## 1. Executive Summary
- One paragraph overview of target's security posture
- Overall risk rating (Critical/High/Medium/Low)

## 2. Critical Findings (Top 3)
For each critical finding:
- **Vulnerability Name & CVE** (if applicable)
- **Exploitability Assessment** (Easy/Medium/Hard)
- **Business Impact** (What attacker can achieve)
- **Exploitation Steps** (Step-by-step with specific commands)
- **Remediation** (Exact steps to fix)

## 3. Additional Vulnerabilities
- List medium/low severity findings (brief)

## 4. Attack Path Recommendations
- Suggest next steps for deeper pentesting
- Specific tools/techniques to try manually

## 5. False Positives Assessment
- Identify likely false positives and explain why

Format your response in **markdown** with proper headers and code blocks for commands.
Use ```bash for shell commands and ```python for scripts.
"""

    return prompt
AI Response Parsing & Storage
Storage Schema:
Python
# app/models/analysis.py
from sqlalchemy import Column, String, Integer, Float, Text, ForeignKey
from sqlalchemy.dialects.postgresql import UUID, JSON
import uuid

class AIAnalysis(Base):
    __tablename__ = 'ai_analyses'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    scan_id = Column(UUID(as_uuid=True), ForeignKey('scans.id'), unique=True)

    model_used = Column(String, nullable=False)  # 'gemini-1.5-flash-002'
    prompt_tokens = Column(Integer, nullable=False)
    completion_tokens = Column(Integer, nullable=False)
    cost_usd = Column(Float, nullable=False)  # Estimated cost

    analysis_text = Column(Text, nullable=False)  # Full markdown output
    structured_data = Column(JSON, nullable=True)  # Parsed sections (optional)

    created_at = Column(DateTime, default=datetime.utcnow)
Cost Calculation:
Python
# Gemini 1.5 Flash pricing (as of 2024)
GEMINI_FLASH_PRICING = {
    'input': 0.075 / 1_000_000,   # $0.075 per 1M tokens
    'output': 0.30 / 1_000_000,   # $0.30 per 1M tokens
}

def calculate_cost(prompt_tokens: int, completion_tokens: int) -> float:
    input_cost = prompt_tokens * GEMINI_FLASH_PRICING['input']
    output_cost = completion_tokens * GEMINI_FLASH_PRICING['output']
    return round(input_cost + output_cost, 6)

# Example: 5000 input, 1000 output
# Cost = (5000 * 0.000000075) + (1000 * 0.00000030)
#      = 0.000375 + 0.0003 = 0.000675 USD (~$0.0007 per scan)
üìä DATABASE SCHEMA (SQLITE)
SQLAlchemy Models:
1. Scan Model:
Python
# app/models/scan.py
from sqlalchemy import Column, String, DateTime, Enum, JSON
from sqlalchemy.dialects.postgresql import UUID
import uuid
import enum

class ScanStatus(str, enum.Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

class Scan(Base):
    __tablename__ = 'scans'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    target = Column(String, nullable=False, index=True)

    tools = Column(JSON, nullable=False)  # ["nmap", "nuclei", "whatweb"]
    profile = Column(String, nullable=False)  # "quick", "normal", "aggressive"

    status = Column(Enum(ScanStatus), default=ScanStatus.PENDING, index=True)
    current_tool = Column(String, nullable=True)  # For progress tracking

    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    error_message = Column(String, nullable=True)

    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    results = relationship("ScanResult", back_populates="scan", cascade="all, delete-orphan")
    analysis = relationship("AIAnalysis", back_populates="scan", uselist=False)
2. ScanResult Model:
Python
# app/models/result.py
class ScanResult(Base):
    __tablename__ = 'scan_results'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    scan_id = Column(UUID(as_uuid=True), ForeignKey('scans.id'), nullable=False)

    tool_name = Column(String, nullable=False)  # "nmap", "nuclei", etc.

    raw_output = Column(Text, nullable=False)  # Full stdout
    parsed_output = Column(JSON, nullable=True)  # Structured data

    exit_code = Column(Integer, nullable=False)
    execution_time = Column(Float, nullable=False)  # Seconds
    error_message = Column(Text, nullable=True)  # stderr if failed

    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationship
    scan = relationship("Scan", back_populates="results")
3. AIAnalysis Model:
Python
# (Already defined above)
class AIAnalysis(Base):
    __tablename__ = 'ai_analyses'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    scan_id = Column(UUID(as_uuid=True), ForeignKey('scans.id'), unique=True)

    model_used = Column(String, nullable=False)
    prompt_tokens = Column(Integer, nullable=False)
    completion_tokens = Column(Integer, nullable=False)
    cost_usd = Column(Float, nullable=False)

    analysis_text = Column(Text, nullable=False)

    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationship
    scan = relationship("Scan", back_populates="analysis")
Database Migrations (Alembic):
Initial Migration:

bash
# Initialize Alembic
alembic init alembic

# Create first migration
alembic revision --autogenerate -m "Initial schema: scans, scan_results, ai_analyses"

# Apply migration
alembic upgrade head
Migration File Example:

Python
# alembic/versions/001_initial_schema.py
def upgrade():
    op.create_table(
        'scans',
        sa.Column('id', UUID(), primary_key=True),
        sa.Column('target', sa.String(), nullable=False),
        sa.Column('tools', JSON(), nullable=False),
        sa.Column('status', sa.Enum('pending', 'running', 'completed', 'failed'), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        # ... other columns
    )

    op.create_table('scan_results', ...)
    op.create_table('ai_analyses', ...)

    # Create indexes
    op.create_index('ix_scans_target', 'scans', ['target'])
    op.create_index('ix_scans_status', 'scans', ['status'])

def downgrade():
    op.drop_table('ai_analyses')
    op.drop_table('scan_results')
    op.drop_table('scans')
üõ†Ô∏è TOOL INTEGRATION (DETAILED)
Base Tool Class (Abstract):
Python
# app/tools/base.py
from abc import ABC, abstractmethod
from typing import Dict, Any, List
from dataclasses import dataclass
import subprocess
import time

@dataclass
class ToolResult:
    tool_name: str
    exit_code: int
    stdout: str
    stderr: str
    execution_time: float
    parsed_data: Dict[str, Any] = None

class BaseTool(ABC):
    def __init__(self):
        self.name: str = ""
        self.timeout: int = 300  # 5 minutes default

    @abstractmethod
    def is_installed(self) -> bool:
        """Check if tool is installed and accessible"""
        pass

    @abstractmethod
    def build_command(self, target: str, profile: str) -> List[str]:
        """Build command arguments list"""
        pass

    @abstractmethod
    def parse_output(self, stdout: str) -> Dict[str, Any]:
        """Parse tool output to structured data"""
        pass

    def execute(self, target: str, profile: str = 'normal') -> ToolResult:
        """Execute tool and return result"""
        if not self.is_installed():
            raise ToolNotInstalledError(f"{self.name} is not installed")

        cmd = self.build_command(target, profile)

        start_time = time.time()

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout,
                shell=False  # CRITICAL
            )

            execution_time = time.time() - start_time

            parsed = None
            if result.returncode == 0:
                parsed = self.parse_output(result.stdout)

            return ToolResult(
                tool_name=self.name,
                exit_code=result.returncode,
                stdout=result.stdout,
                stderr=result.stderr,
                execution_time=execution_time,
                parsed_data=parsed
            )

        except subprocess.TimeoutExpired:
            execution_time = time.time() - start_time
            return ToolResult(
                tool_name=self.name,
                exit_code=-1,
                stdout="",
                stderr=f"Timeout after {self.timeout} seconds",
                execution_time=execution_time
            )
Tool Implementations:
1. Nmap Tool:
Python
# app/tools/nmap_tool.py
import nmap
import xmltodict

class NmapTool(BaseTool):
    def __init__(self):
        super().__init__()
        self.name = "nmap"
        self.timeout = 600  # 10 minutes for aggressive scans

    def is_installed(self) -> bool:
        try:
            result = subprocess.run(['nmap', '--version'],
                                  capture_output=True,
                                  timeout=5)
            return result.returncode == 0
        except:
            return False

    def build_command(self, target: str, profile: str) -> List[str]:
        base_cmd = ['nmap']

        if profile == 'quick':
            base_cmd.extend(['-F', '-sV'])  # Fast scan, top 100 ports
        elif profile == 'normal':
            base_cmd.extend(['-sV', '-sC'])  # Default scripts
        elif profile == 'aggressive':
            base_cmd.extend(['-A', '-T4', '-p-'])  # All ports, OS detection

        # Output XML to stdout
        base_cmd.extend(['-oX', '-', target])

        return base_cmd

    def parse_output(self, stdout: str) -> Dict[str, Any]:
        """Parse Nmap XML output"""
        try:
            # Parse XML
            data = xmltodict.parse(stdout)

            host = data['nmaprun']['host']

            # Extract open ports
            open_ports = []
            ports = host.get('ports', {}).get('port', [])

            # Handle single port (not a list)
            if isinstance(ports, dict):
                ports = [ports]

            for port in ports:
                if port['state']['@state'] == 'open':
                    open_ports.append({
                        'port': int(port['@portid']),
                        'protocol': port['@protocol'],
                        'service': port['service']['@name'],
                        'version': port['service'].get('@product', '') + ' ' +
                                  port['service'].get('@version', ''),
                        'cpe': port['service'].get('cpe', [])
                    })

            # Extract OS detection
            os_match = None
            if 'os' in host and 'osmatch' in host['os']:
                os_matches = host['os']['osmatch']
                if isinstance(os_matches, list):
                    os_match = os_matches[0]['@name']  # Best match
                else:
                    os_match = os_matches['@name']

            return {
                'target': host['address']['@addr'],
                'hostname': host.get('hostnames', {}).get('hostname', {}).get('@name'),
                'open_ports': open_ports,
                'os_detection': os_match,
                'scan_stats': {
                    'up_hosts': data['nmaprun']['runstats']['hosts']['@up'],
                    'total_hosts': data['nmaprun']['runstats']['hosts']['@total'],
                }
            }

        except Exception as e:
            logger.error(f"Failed to parse Nmap output: {e}")
            return {'error': str(e), 'raw_output': stdout}
2. Nuclei Tool:
Python
# app/tools/nuclei_tool.py
import json

class NucleiTool(BaseTool):
    def __init__(self):
        super().__init__()
        self.name = "nuclei"
        self.timeout = 900  # 15 minutes

    def is_installed(self) -> bool:
        try:
            result = subprocess.run(['nuclei', '-version'],
                                  capture_output=True,
                                  timeout=5)
            return result.returncode == 0
        except:
            return False

    def build_command(self, target: str, profile: str) -> List[str]:
        base_cmd = ['nuclei', '-u', target, '-json']

        # Severity filter based on profile
        if profile == 'quick':
            base_cmd.extend(['-severity', 'critical'])
        elif profile == 'normal':
            base_cmd.extend(['-severity', 'high,critical'])
        elif profile == 'aggressive':
            base_cmd.extend(['-severity', 'medium,high,critical'])

        # Silent mode (no banner)
        base_cmd.append('-silent')

        return base_cmd

    def parse_output(self, stdout: str) -> Dict[str, Any]:
        """Parse Nuclei JSON Lines output"""
        findings = []

        # Each line is a JSON object
        for line in stdout.strip().split('\n'):
            if not line:
                continue

            try:
                data = json.loads(line)

                findings.append({
                    'template_id': data['template-id'],
                    'template_name': data['info']['name'],
                    'severity': data['info']['severity'],
                    'description': data['info'].get('description', ''),
                    'matched_at': data['matched-at'],
                    'matcher_name': data.get('matcher-name', ''),
                    'cve_id': data['info'].get('classification', {}).get('cve-id'),
                    'cvss_score': data['info'].get('classification', {}).get('cvss-score'),
                })
            except json.JSONDecodeError:
                continue

        # Sort by severity
        severity_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
        findings.sort(key=lambda x: severity_order.get(x['severity'], 99))

        return {
            'findings': findings,
            'total_count': len(findings),
            'by_severity': {
                'critical': len([f for f in findings if f['severity'] == 'critical']),
                'high': len([f for f in findings if f['severity'] == 'high']),
                'medium': len([f for f in findings if f['severity'] == 'medium']),
            }
        }
3. whatweb Tool:
Python
# app/tools/whatweb_tool.py
class WhatwebTool(BaseTool):
    def __init__(self):
        super().__init__()
        self.name = "whatweb"
        self.timeout = 60  # 1 minute (very fast)

    def is_installed(self) -> bool:
        try:
            result = subprocess.run(['whatweb', '--version'],
                                  capture_output=True,
                                  timeout=5)
            return result.returncode == 0
        except:
            return False

    def build_command(self, target: str, profile: str) -> List[str]:
        # Profile doesn't affect whatweb much
        aggression = '3' if profile == 'aggressive' else '1'

        return ['whatweb', target, '--aggression', aggression, '--log-json=-']

    def parse_output(self, stdout: str) -> Dict[str, Any]:
        """Parse whatweb JSON output"""
        try:
            data = json.loads(stdout)

            # Extract plugins
            plugins = data[0]['plugins']

            tech_stack = {
                'url': data[0]['target'],
                'http_status': data[0].get('http_status'),
                'server': plugins.get('HTTPServer', {}).get('string', ['Unknown'])[0],
                'cms': None,
                'language': None,
                'js_frameworks': [],
                'all_technologies': list(plugins.keys())
            }

            # Detect CMS
            cms_plugins = ['WordPress', 'Joomla', 'Drupal', 'Magento']
            for cms in cms_plugins:
                if cms in plugins:
                    tech_stack['cms'] = cms
                    break

            # Detect language
            lang_plugins = {'PHP': 'PHP', 'Python': 'Python', 'Ruby': 'Ruby'}
            for plugin, lang in lang_plugins.items():
                if plugin in plugins:
                    tech_stack['language'] = lang
                    break

            # Detect JS frameworks
            js_frameworks = ['jQuery', 'React', 'Vue', 'Angular', 'Bootstrap']
            for framework in js_frameworks:
                if framework in plugins:
                    tech_stack['js_frameworks'].append(framework)

            return tech_stack

        except Exception as e:
            logger.error(f"Failed to parse whatweb output: {e}")
            return {'error': str(e)}
4. sslscan Tool:
Python
# app/tools/sslscan_tool.py
class SSLScanTool(BaseTool):
    def __init__(self):
        super().__init__()
        self.name = "sslscan"
        self.timeout = 120  # 2 minutes

    def is_installed(self) -> bool:
        try:
            result = subprocess.run(['sslscan', '--version'],
                                  capture_output=True,
                                  timeout=5)
            return result.returncode == 0
        except:
            return False

    def build_command(self, target: str, profile: str) -> List[str]:
        # Extract hostname (remove protocol if present)
        target_clean = target.replace('https://', '').replace('http://', '').split('/')[0]

        return ['sslscan', '--xml=-', target_clean]

    def parse_output(self, stdout: str) -> Dict[str, Any]:
        """Parse sslscan XML output"""
        try:
            data = xmltodict.parse(stdout)

            ssltest = data['document']['ssltest']

            # Extract certificate info
            cert = ssltest.get('certificate', {})

            # Extract cipher info
            ciphers = ssltest.get('cipher', [])
            if isinstance(ciphers, dict):
                ciphers = [ciphers]

            # Categorize ciphers
            weak_ciphers = []
            strong_ciphers = []

            for cipher in ciphers:
                if cipher['@status'] == 'accepted':
                    strength = int(cipher['@bits'])
                    cipher_info = {
                        'name': cipher['@cipher'],
                        'strength': strength,
                        'protocol': cipher['@sslversion']
                    }

                    if strength < 128:
                        weak_ciphers.append(cipher_info)
                    else:
                        strong_ciphers.append(cipher_info)

            # Check vulnerabilities
            vulnerabilities = []
            heartbleed = ssltest.get('heartbleed', {}).get('@vulnerable')
            if heartbleed == '1':
                vulnerabilities.append('Heartbleed')

            return {
                'host': ssltest['@host'],
                'certificate': {
                    'valid': cert.get('@expired') != '1',
                    'subject': cert.get('subject', ''),
                    'issuer': cert.get('issuer', ''),
                    'not_after': cert.get('not-valid-after', ''),
                },
                'weak_ciphers': weak_ciphers,
                'strong_ciphers': strong_ciphers,
                'vulnerabilities': vulnerabilities,
                'protocols_supported': list(set([c['protocol'] for c in strong_ciphers + weak_ciphers]))
            }

        except Exception as e:
            logger.error(f"Failed to parse sslscan output: {e}")
            return {'error': str(e)}
Tool Factory:
Python
# app/tools/factory.py
from typing import Dict, Type
from app.tools.base import BaseTool
from app.tools.nmap_tool import NmapTool
from app.tools.nuclei_tool import NucleiTool
from app.tools.whatweb_tool import WhatwebTool
from app.tools.sslscan_tool import SSLScanTool

# Tool registry
TOOL_REGISTRY: Dict[str, Type[BaseTool]] = {
    'nmap': NmapTool,
    'nuclei': NucleiTool,
    'whatweb': WhatwebTool,
    'sslscan': SSLScanTool,
}

def create_tool(tool_name: str) -> BaseTool:
    """Factory method to create tool instances"""
    tool_class = TOOL_REGISTRY.get(tool_name)

    if not tool_class:
        raise ValueError(f"Unknown tool: {tool_name}")

    return tool_class()

def get_available_tools() -> Dict[str, bool]:
    """Check which tools are installed"""
    available = {}

    for tool_name in TOOL_REGISTRY.keys():
        tool = create_tool(tool_name)
        available[tool_name] = tool.is_installed()

    return available
üöÄ API ENDPOINTS (DETAILED)
API Structure:
Code
/api/v1
‚îú‚îÄ‚îÄ /scan
‚îÇ   ‚îú‚îÄ‚îÄ POST   /                # Create new scan
‚îÇ   ‚îú‚îÄ‚îÄ GET    /{scan_id}       # Get scan status & results
‚îÇ   ‚îî‚îÄ‚îÄ DELETE /{scan_id}       # Delete scan
‚îú‚îÄ‚îÄ /scans
‚îÇ   ‚îî‚îÄ‚îÄ GET    /                # List all scans (with pagination)
‚îú‚îÄ‚îÄ /tools
‚îÇ   ‚îî‚îÄ‚îÄ GET    /                # Get available tools
‚îî‚îÄ‚îÄ /validate
    ‚îî‚îÄ‚îÄ POST   /target          # Validate target
Endpoint Implementations:
1. POST /api/v1/scan - Create Scan
Request Schema:

Python
# app/schemas/scan.py
from pydantic import BaseModel, Field, validator
from typing import List

class ScanCreate(BaseModel):
    target: str = Field(..., description="Domain, IP, or URL to scan")
    tools: List[str] = Field(default=['nmap', 'nuclei'],
                             description="Tools to execute")
    profile: str = Field(default='normal',
                        description="Scan profile: quick, normal, aggressive")
    enable_ai_analysis: bool = Field(default=True)

    @validator('tools')
    def validate_tools(cls, v):
        valid_tools = ['nmap', 'nuclei', 'whatweb', 'sslscan']
        for tool in v:
            if tool not in valid_tools:
                raise ValueError(f"Invalid tool: {tool}")
        return v

    @validator('profile')
    def validate_profile(cls, v):
        if v not in ['quick', 'normal', 'aggressive']:
            raise ValueError("Profile must be quick, normal, or aggressive")
        return v
Endpoint Implementation:

Python
# app/api/v1/endpoints/scan.py
from fastapi import APIRouter, Depends, HTTPException, Header
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.schemas.scan import ScanCreate, ScanResponse
from app.services.scanner_service import ScannerService
from app.services.validation_service import ValidationService
from app.utils.logger import logger

router = APIRouter()

@router.post('/', response_model=ScanResponse, status_code=201)
async def create_scan(
    data: ScanCreate,
    x_gemini_api_key: str = Header(None),
    db: Session = Depends(get_db)
):
    """
    Create a new scan

    - **target**: Domain, IP, or URL to scan
    - **tools**: List of tools to execute
    - **profile**: Scan intensity (quick/normal/aggressive)
    - **enable_ai_analysis**: Whether to run AI analysis after scan
    """

    # Validate target
    validator = ValidationService()

    try:
        sanitized_target = validator.sanitize_target(data.target)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    # Check if target is blacklisted
    if validator.is_blacklisted(sanitized_target):
        raise HTTPException(
            status_code=403,
            detail="Target is blacklisted (private IP or restricted)"
        )

    # Validate API key if AI analysis enabled
    if data.enable_ai_analysis and not x_gemini_api_key:
        raise HTTPException(
            status_code=400,
            detail="Gemini API key required for AI analysis"
        )

    # Create scan record
    scan = Scan(
        target=sanitized_target,
        tools=data.tools,
        profile=data.profile,
        status=ScanStatus.PENDING
    )

    db.add(scan)
    db.commit()
    db.refresh(scan)

    logger.info(f"Scan created: {scan.id}, target={sanitized_target}, tools={data.tools}")

    # Execute scan (synchronous for MVP, async dengan Celery nanti)
    try:
        scanner_service = ScannerService(db)
        scanner_service.execute_scan(
            scan_id=scan.id,
            gemini_api_key=x_gemini_api_key if data.enable_ai_analysis else None
        )
    except Exception as e:
        logger.error(f"Scan execution failed: {scan.id}, error={str(e)}")
        scan.status = ScanStatus.FAILED
        scan.error_message = str(e)
        db.commit()

    return scan
2. GET /api/v1/scan/{scan_id} - Get Scan
Python
@router.get('/{scan_id}', response_model=ScanDetailResponse)
async def get_scan(scan_id: UUID, db: Session = Depends(get_db)):
    """Get scan details, results, and AI analysis"""

    scan = db.query(Scan).filter(Scan.id == scan_id).first()

    if not scan:
        raise HTTPException(status_code=404, detail="Scan not found")

    # Include relationships (results, analysis)
    response = {
        'id': scan.id,
        'target': scan.target,
        'tools': scan.tools,
        'profile': scan.profile,
        'status': scan.status,
        'current_tool': scan.current_tool,
        'started_at': scan.started_at,
        'completed_at': scan.completed_at,
        'created_at': scan.created_at,
        'results': [
            {
                'tool_name': r.tool_name,
                'exit_code': r.exit_code,
                'execution_time': r.execution_time,
                'parsed_output': r.parsed_output,
                'raw_output': r.raw_output if scan.status == ScanStatus.COMPLETED else None
            }
            for r in scan.results
        ],
        'analysis': {
            'model_used': scan.analysis.model_used,
            'analysis_text': scan.analysis.analysis_text,
            'cost_usd': scan.analysis.cost_usd,
            'tokens': {
                'prompt': scan.analysis.prompt_tokens,
                'completion': scan.analysis.completion_tokens
            }
        } if scan.analysis else None
    }

    return response

    3. GET /api/v1/scans - List Scans (CONTINUED)
Python
# app/schemas/scan.py
class ScanListParams(BaseModel):
    page: int = Field(default=1, ge=1)
    per_page: int = Field(default=20, ge=1, le=100)
    status: Optional[str] = None
    search: Optional[str] = None  # Search by target

class ScanListResponse(BaseModel):
    total: int
    page: int
    per_page: int
    total_pages: int
    scans: List[ScanSummary]

class ScanSummary(BaseModel):
    id: UUID
    target: str
    tools: List[str]
    status: str
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    duration: Optional[float]  # Seconds
    vulnerabilities_found: int
Endpoint Implementation:

Python
# app/api/v1/endpoints/scan.py
@router.get('/', response_model=ScanListResponse)
async def list_scans(
    page: int = Query(1, ge=1),
    per_page: int = Query(20, ge=1, le=100),
    status: Optional[str] = Query(None),
    search: Optional[str] = Query(None),
    db: Session = Depends(get_db)
):
    """
    List all scans with pagination and filtering

    - **page**: Page number (starting from 1)
    - **per_page**: Items per page (max 100)
    - **status**: Filter by status (pending/running/completed/failed)
    - **search**: Search by target (partial match)
    """

    # Base query
    query = db.query(Scan)

    # Apply filters
    if status:
        query = query.filter(Scan.status == status)

    if search:
        query = query.filter(Scan.target.ilike(f'%{search}%'))

    # Get total count
    total = query.count()

    # Apply pagination
    offset = (page - 1) * per_page
    scans = query.order_by(Scan.created_at.desc()).offset(offset).limit(per_page).all()

    # Calculate total pages
    total_pages = (total + per_page - 1) // per_page

    # Build response
    scan_summaries = []
    for scan in scans:
        # Calculate duration
        duration = None
        if scan.started_at and scan.completed_at:
            duration = (scan.completed_at - scan.started_at).total_seconds()

        # Count vulnerabilities (from Nuclei results)
        vuln_count = 0
        for result in scan.results:
            if result.tool_name == 'nuclei' and result.parsed_output:
                vuln_count = result.parsed_output.get('total_count', 0)

        scan_summaries.append(ScanSummary(
            id=scan.id,
            target=scan.target,
            tools=scan.tools,
            status=scan.status.value,
            started_at=scan.started_at,
            completed_at=scan.completed_at,
            duration=duration,
            vulnerabilities_found=vuln_count
        ))

    return ScanListResponse(
        total=total,
        page=page,
        per_page=per_page,
        total_pages=total_pages,
        scans=scan_summaries
    )
4. DELETE /api/v1/scan/{scan_id} - Delete Scan
Python
@router.delete('/{scan_id}', status_code=204)
async def delete_scan(scan_id: UUID, db: Session = Depends(get_db)):
    """Delete a scan and all related data"""

    scan = db.query(Scan).filter(Scan.id == scan_id).first()

    if not scan:
        raise HTTPException(status_code=404, detail="Scan not found")

    # Check if scan is running
    if scan.status == ScanStatus.RUNNING:
        raise HTTPException(
            status_code=400,
            detail="Cannot delete running scan. Please wait for completion."
        )

    # Delete (cascade will delete results and analysis)
    db.delete(scan)
    db.commit()

    logger.info(f"Scan deleted: {scan_id}")

    return None
5. GET /api/v1/tools - Get Available Tools
Python
# app/api/v1/endpoints/tools.py
from fastapi import APIRouter
from app.tools.factory import get_available_tools, TOOL_REGISTRY

router = APIRouter()

@router.get('/')
async def get_tools():
    """
    Get list of supported tools and their installation status
    """
    available = get_available_tools()

    tools_info = []
    for tool_name, is_installed in available.items():
        tool_class = TOOL_REGISTRY[tool_name]
        tool_instance = tool_class()

        tools_info.append({
            'name': tool_name,
            'installed': is_installed,
            'timeout': tool_instance.timeout,
            'description': _get_tool_description(tool_name)
        })

    return {
        'tools': tools_info,
        'total': len(tools_info),
        'installed_count': sum(1 for t in tools_info if t['installed'])
    }

def _get_tool_description(tool_name: str) -> str:
    descriptions = {
        'nmap': 'Network port scanner and service detection',
        'nuclei': 'Vulnerability scanner with 10,000+ templates',
        'whatweb': 'Web technology identification (CMS, frameworks, servers)',
        'sslscan': 'SSL/TLS configuration and vulnerability scanner'
    }
    return descriptions.get(tool_name, '')
6. POST /api/v1/validate/target - Validate Target
Python
# app/api/v1/endpoints/validate.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.services.validation_service import ValidationService

router = APIRouter()

class TargetValidateRequest(BaseModel):
    target: str

class TargetValidateResponse(BaseModel):
    valid: bool
    sanitized_target: Optional[str]
    error: Optional[str]
    is_blacklisted: bool
    resolved_ip: Optional[str]

@router.post('/target', response_model=TargetValidateResponse)
async def validate_target(data: TargetValidateRequest):
    """
    Validate target before scanning

    - Check format (domain/IP/URL)
    - Sanitize input
    - Check blacklist
    - Resolve DNS
    """
    validator = ValidationService()

    try:
        # Sanitize
        sanitized = validator.sanitize_target(data.target)

        # Check blacklist
        is_blacklisted = validator.is_blacklisted(sanitized)

        # Resolve IP
        resolved_ip = None
        try:
            resolved_ip = validator.resolve_to_ip(sanitized)
        except:
            pass

        return TargetValidateResponse(
            valid=True,
            sanitized_target=sanitized,
            error=None,
            is_blacklisted=is_blacklisted,
            resolved_ip=resolved_ip
        )

    except ValueError as e:
        return TargetValidateResponse(
            valid=False,
            sanitized_target=None,
            error=str(e),
            is_blacklisted=False,
            resolved_ip=None
        )
üé® FRONTEND IMPLEMENTATION (DETAILED)
Page Components:
1. Home Page (Dashboard) - /app/page.tsx
TypeScript
// src/app/page.tsx
import { StatsCards } from '@/components/dashboard/StatsCards';
import { RecentScans } from '@/components/dashboard/RecentScans';
import { QuickActions } from '@/components/dashboard/QuickActions';

export default function HomePage() {
  return (
    <div className="container mx-auto py-8 px-4">
      <h1 className="text-4xl font-bold mb-8">AI Pentest Agent</h1>

      {/* Stats Overview */}
      <StatsCards />

      {/* Quick Actions */}
      <QuickActions />

      {/* Recent Scans Table */}
      <div className="mt-12">
        <h2 className="text-2xl font-semibold mb-4">Recent Scans</h2>
        <RecentScans />
      </div>
    </div>
  );
}
StatsCards Component:

TypeScript
// src/components/dashboard/StatsCards.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { Card } from '@/components/ui/Card';
import { api } from '@/lib/api';
import { Activity, Shield, AlertTriangle, DollarSign } from 'lucide-react';

export function StatsCards() {
  const { data: scans } = useQuery({
    queryKey: ['scans', 'summary'],
    queryFn: async () => {
      const response = await api.get('/scans?per_page=1000');
      return response.data.scans;
    }
  });

  const totalScans = scans?.length || 0;
  const activeScans = scans?.filter(s => s.status === 'running').length || 0;
  const totalVulns = scans?.reduce((sum, s) => sum + (s.vulnerabilities_found || 0), 0) || 0;

  // Calculate AI cost (mock for now, real implementation would query database)
  const aiCost = 0.05; // Example

  const stats = [
    {
      title: 'Total Scans',
      value: totalScans,
      icon: Activity,
      color: 'text-blue-500'
    },
    {
      title: 'Active Scans',
      value: activeScans,
      icon: Shield,
      color: 'text-green-500'
    },
    {
      title: 'Vulnerabilities Found',
      value: totalVulns,
      icon: AlertTriangle,
      color: 'text-red-500'
    },
    {
      title: 'AI Cost (Month)',
      value: `$${aiCost.toFixed(2)}`,
      icon: DollarSign,
      color: 'text-purple-500'
    }
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
      {stats.map((stat) => {
        const Icon = stat.icon;
        return (
          <Card key={stat.title} className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-500">{stat.title}</p>
                <p className="text-3xl font-bold mt-2">{stat.value}</p>
              </div>
              <Icon className={`w-12 h-12 ${stat.color}`} />
            </div>
          </Card>
        );
      })}
    </div>
  );
}
2. New Scan Page - /app/scan/page.tsx
TypeScript
// src/app/scan/page.tsx
'use client';

import { ScanForm } from '@/components/scan/ScanForm';
import { Card } from '@/components/ui/Card';

export default function NewScanPage() {
  return (
    <div className="container mx-auto py-8 px-4">
      <h1 className="text-3xl font-bold mb-8">Start New Scan</h1>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Left: Scan Configuration Form */}
        <div>
          <Card className="p-6">
            <ScanForm />
          </Card>
        </div>

        {/* Right: Info Panel */}
        <div>
          <Card className="p-6">
            <h2 className="text-xl font-semibold mb-4">Scan Information</h2>

            <div className="space-y-4">
              <div>
                <h3 className="font-medium text-sm text-gray-700">Scan Profiles</h3>
                <ul className="mt-2 space-y-2 text-sm">
                  <li>
                    <span className="font-semibold">Quick:</span> 2-3 minutes, top ports only
                  </li>
                  <li>
                    <span className="font-semibold">Normal:</span> 5-7 minutes, comprehensive scan
                  </li>
                  <li>
                    <span className="font-semibold">Aggressive:</span> 10-15 minutes, full scan with OS detection
                  </li>
                </ul>
              </div>

              <div className="border-t pt-4">
                <h3 className="font-medium text-sm text-gray-700">Available Tools</h3>
                <ul className="mt-2 space-y-2 text-sm">
                  <li><strong>Nmap:</strong> Port scanning & service detection</li>
                  <li><strong>Nuclei:</strong> Vulnerability scanning</li>
                  <li><strong>whatweb:</strong> Technology identification</li>
                  <li><strong>sslscan:</strong> SSL/TLS analysis</li>
                </ul>
              </div>
            </div>
          </Card>
        </div>
      </div>
    </div>
  );
}
ScanForm Component:

TypeScript
// src/components/scan/ScanForm.tsx
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useMutation, useQuery } from '@tanstack/react-query';
import { useRouter } from 'next/navigation';
import { api } from '@/lib/api';
import { Button } from '@/components/ui/Button';
import { Input } from '@/components/ui/Input';
import { Checkbox } from '@/components/ui/Checkbox';
import { Select } from '@/components/ui/Select';
import { toast } from 'react-hot-toast';
import { useStore } from '@/store/useStore';

const scanSchema = z.object({
  target: z.string().min(1, 'Target is required'),
  tools: z.array(z.string()).min(1, 'Select at least one tool'),
  profile: z.enum(['quick', 'normal', 'aggressive']),
  geminiApiKey: z.string().optional(),
  enableAiAnalysis: z.boolean()
});

type ScanFormData = z.infer<typeof scanSchema>;

export function ScanForm() {
  const router = useRouter();
  const { geminiApiKey, setGeminiApiKey } = useStore();
  const [targetValidation, setTargetValidation] = useState<any>(null);

  const { register, handleSubmit, watch, setValue, formState: { errors } } = useForm<ScanFormData>({
    resolver: zodResolver(scanSchema),
    defaultValues: {
      tools: ['nmap', 'nuclei'],
      profile: 'normal',
      enableAiAnalysis: true,
      geminiApiKey: geminiApiKey || ''
    }
  });

  const watchTarget = watch('target');
  const watchEnableAi = watch('enableAiAnalysis');

  // Get available tools
  const { data: toolsData } = useQuery({
    queryKey: ['tools'],
    queryFn: async () => {
      const response = await api.get('/tools');
      return response.data.tools;
    }
  });

  // Validate target (debounced)
  const validateTargetMutation = useMutation({
    mutationFn: async (target: string) => {
      const response = await api.post('/validate/target', { target });
      return response.data;
    },
    onSuccess: (data) => {
      setTargetValidation(data);

      if (data.is_blacklisted) {
        toast.error('Target is blacklisted (private IP or restricted)');
      }
    }
  });

  // Create scan mutation
  const createScanMutation = useMutation({
    mutationFn: async (data: ScanFormData) => {
      const headers: any = {};

      if (data.enableAiAnalysis && data.geminiApiKey) {
        headers['X-Gemini-API-Key'] = data.geminiApiKey;
        // Save to store for future use
        setGeminiApiKey(data.geminiApiKey);
      }

      const response = await api.post('/scan', {
        target: data.target,
        tools: data.tools,
        profile: data.profile,
        enable_ai_analysis: data.enableAiAnalysis
      }, { headers });

      return response.data;
    },
    onSuccess: (data) => {
      toast.success('Scan started successfully!');
      router.push(`/scan/${data.id}`);
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.detail || 'Failed to start scan');
    }
  });

  const onSubmit = (data: ScanFormData) => {
    if (targetValidation && targetValidation.is_blacklisted) {
      toast.error('Cannot scan blacklisted target');
      return;
    }

    if (data.enableAiAnalysis && !data.geminiApiKey) {
      toast.error('Gemini API key required for AI analysis');
      return;
    }

    createScanMutation.mutate(data);
  };

  // Validate target on blur
  const handleTargetBlur = () => {
    if (watchTarget && watchTarget.length > 0) {
      validateTargetMutation.mutate(watchTarget);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Target Input */}
      <div>
        <label className="block text-sm font-medium mb-2">
          Target <span className="text-red-500">*</span>
        </label>
        <Input
          {...register('target')}
          placeholder="example.com or 192.168.1.1 or https://example.com"
          onBlur={handleTargetBlur}
          className={errors.target ? 'border-red-500' : ''}
        />

        {/* Validation Feedback */}
        {targetValidation && (
          <div className="mt-2 text-sm">
            {targetValidation.valid ? (
              <span className="text-green-600">
                ‚úì Valid target: {targetValidation.sanitized_target}
                {targetValidation.resolved_ip && ` ‚Üí ${targetValidation.resolved_ip}`}
              </span>
            ) : (
              <span className="text-red-600">
                ‚úó {targetValidation.error}
              </span>
            )}
          </div>
        )}

        {errors.target && (
          <p className="mt-1 text-sm text-red-600">{errors.target.message}</p>
        )}
      </div>

      {/* Tool Selection */}
      <div>
        <label className="block text-sm font-medium mb-2">
          Tools <span className="text-red-500">*</span>
        </label>
        <div className="space-y-2">
          {toolsData?.map((tool: any) => (
            <label key={tool.name} className="flex items-center space-x-2">
              <Checkbox
                {...register('tools')}
                value={tool.name}
                disabled={!tool.installed}
              />
              <span className={!tool.installed ? 'text-gray-400' : ''}>
                {tool.name}
                {!tool.installed && ' (not installed)'}
              </span>
            </label>
          ))}
        </div>
        {errors.tools && (
          <p className="mt-1 text-sm text-red-600">{errors.tools.message}</p>
        )}
      </div>

      {/* Scan Profile */}
      <div>
        <label className="block text-sm font-medium mb-2">Scan Profile</label>
        <Select {...register('profile')}>
          <option value="quick">Quick (2-3 min)</option>
          <option value="normal">Normal (5-7 min)</option>
          <option value="aggressive">Aggressive (10-15 min)</option>
        </Select>
      </div>

      {/* AI Analysis Toggle */}
      <div>
        <label className="flex items-center space-x-2">
          <Checkbox {...register('enableAiAnalysis')} />
          <span className="text-sm font-medium">Enable AI Analysis</span>
        </label>
      </div>

      {/* API Key Input (conditional) */}
      {watchEnableAi && (
        <div>
          <label className="block text-sm font-medium mb-2">
            Google Gemini API Key <span className="text-red-500">*</span>
          </label>
          <Input
            {...register('geminiApiKey')}
            type="password"
            placeholder="Enter your Gemini API key"
            className={errors.geminiApiKey ? 'border-red-500' : ''}
          />
          <p className="mt-1 text-xs text-gray-500">
            Your API key is never stored on the server. It's only used for this request.
          </p>
          {errors.geminiApiKey && (
            <p className="mt-1 text-sm text-red-600">{errors.geminiApiKey.message}</p>
          )}
        </div>
      )}

      {/* Submit Button */}
      <Button
        type="submit"
        disabled={createScanMutation.isPending}
        className="w-full"
      >
        {createScanMutation.isPending ? 'Starting Scan...' : 'Start Scan'}
      </Button>
    </form>
  );
}
3. Scan Detail Page - /app/scan/[id]/page.tsx
TypeScript
// src/app/scan/[id]/page.tsx
'use client';

import { useParams } from 'next/navigation';
import { useQuery } from '@tanstack/react-query';
import { api } from '@/lib/api';
import { ScanStatus } from '@/components/scan/ScanStatus';
import { ScanProgress } from '@/components/scan/ScanProgress';
import { ScanResults } from '@/components/scan/ScanResults';
import { AIAnalysis } from '@/components/analysis/AIAnalysis';
import { Tabs } from '@/components/ui/Tabs';
import { Card } from '@/components/ui/Card';

export default function ScanDetailPage() {
  const params = useParams();
  const scanId = params.id as string;

  // Poll scan status every 3 seconds if running
  const { data: scan, isLoading } = useQuery({
    queryKey: ['scan', scanId],
    queryFn: async () => {
      const response = await api.get(`/scan/${scanId}`);
      return response.data;
    },
    refetchInterval: (data) => {
      // Poll every 3 seconds if running, otherwise don't refetch
      return data?.status === 'running' ? 3000 : false;
    }
  });

  if (isLoading) {
    return <div className="container mx-auto py-8">Loading...</div>;
  }

  if (!scan) {
    return <div className="container mx-auto py-8">Scan not found</div>;
  }

  const isRunning = scan.status === 'running';
  const isCompleted = scan.status === 'completed';
  const isFailed = scan.status === 'failed';

  return (
    <div className="container mx-auto py-8 px-4">
      {/* Header */}
      <div className="mb-8">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold">{scan.target}</h1>
            <p className="text-gray-500 mt-1">Scan ID: {scan.id}</p>
          </div>
          <ScanStatus status={scan.status} />
        </div>

        <div className="mt-4 flex gap-4 text-sm text-gray-600">
          <span>Started: {new Date(scan.started_at).toLocaleString()}</span>
          {scan.completed_at && (
            <span>
              Duration: {((new Date(scan.completed_at) - new Date(scan.started_at)) / 1000).toFixed(0)}s
            </span>
          )}
        </div>
      </div>

      {/* Progress (if running) */}
      {isRunning && (
        <Card className="p-6 mb-8">
          <ScanProgress scan={scan} />
        </Card>
      )}

      {/* Error Message (if failed) */}
      {isFailed && (
        <Card className="p-6 mb-8 border-red-300 bg-red-50">
          <h3 className="text-red-700 font-semibold mb-2">Scan Failed</h3>
          <p className="text-red-600">{scan.error_message}</p>
        </Card>
      )}

      {/* Results Tabs (if completed) */}
      {isCompleted && (
        <Tabs defaultValue="analysis">
          <Tabs.List>
            {scan.analysis && <Tabs.Tab value="analysis">AI Analysis</Tabs.Tab>}
            <Tabs.Tab value="results">Tool Results</Tabs.Tab>
          </Tabs.List>

          {scan.analysis && (
            <Tabs.Panel value="analysis">
              <AIAnalysis analysis={scan.analysis} />
            </Tabs.Panel>
          )}

          <Tabs.Panel value="results">
            <ScanResults results={scan.results} />
          </Tabs.Panel>
        </Tabs>
      )}
    </div>
  );
}
AI Analysis Component:

TypeScript
// src/components/analysis/AIAnalysis.tsx
'use client';

import ReactMarkdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/cjs/styles/prism';
import { Card } from '@/components/ui/Card';

interface AIAnalysisProps {
  analysis: {
    model_used: string;
    analysis_text: string;
    cost_usd: number;
    tokens: {
      prompt: number;
      completion: number;
    };
  };
}

export function AIAnalysis({ analysis }: AIAnalysisProps) {
  return (
    <div className="space-y-6">
      {/* Metadata */}
      <Card className="p-4 bg-gray-50">
        <div className="flex justify-between text-sm">
          <span>Model: <strong>{analysis.model_used}</strong></span>
          <span>Cost: <strong>${analysis.cost_usd.toFixed(6)}</strong></span>
          <span>
            Tokens: <strong>{analysis.tokens.prompt + analysis.tokens.completion}</strong>
          </span>
        </div>
      </Card>

      {/* AI Output */}
      <Card className="p-6 prose prose-sm max-w-none">
        <ReactMarkdown
          components={{
            code({ node, inline, className, children, ...props }) {
              const match = /language-(\w+)/.exec(className || '');
              return !inline && match ? (
                <SyntaxHighlighter
                  style={vscDarkPlus}
                  language={match[1]}
                  PreTag="div"
                  {...props}
                >
                  {String(children).replace(/\n$/, '')}
                </SyntaxHighlighter>
              ) : (
                <code className={className} {...props}>
                  {children}
                </code>
              );
            }
          }}
        >
          {analysis.analysis_text}
        </ReactMarkdown>
      </Card>
    </div>
  );
}
4. History Page - /app/history/page.tsx
TypeScript
// src/app/history/page.tsx
'use client';

import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import { Card } from '@/components/ui/Card';
import { Button } from '@/components/ui/Button';
import { Input } from '@/components/ui/Input';
import { Badge } from '@/components/ui/Badge';
import { Trash2, Eye } from 'lucide-react';
import { useRouter } from 'next/navigation';
import { toast } from 'react-hot-toast';

export default function HistoryPage() {
  const router = useRouter();
  const queryClient = useQueryClient();
  const [page, setPage] = useState(1);
  const [search, setSearch] = useState('');

  const { data, isLoading } = useQuery({
    queryKey: ['scans', page, search],
    queryFn: async () => {
      const response = await api.get('/scans', {
        params: { page, per_page: 20, search }
      });
      return response.data;
    }
  });

  const deleteMutation = useMutation({
    mutationFn: async (scanId: string) => {
      await api.delete(`/scan/${scanId}`);
    },
    onSuccess: () => {
      toast.success('Scan deleted');
      queryClient.invalidateQueries({ queryKey: ['scans'] });
    },
    onError: () => {
      toast.error('Failed to delete scan');
    }
  });

  const getStatusColor = (status: string) => {
    const colors = {
      pending: 'bg-yellow-100 text-yellow-800',
      running: 'bg-blue-100 text-blue-800',
      completed: 'bg-green-100 text-green-800',
      failed: 'bg-red-100 text-red-800'
    };
    return colors[status as keyof typeof colors] || 'bg-gray-100 text-gray-800';
  };

  return (
    <div className="container mx-auto py-8 px-4">
      <h1 className="text-3xl font-bold mb-8">Scan History</h1>

      {/* Search */}
      <Card className="p-4 mb-6">
        <Input
          placeholder="Search by target..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="max-w-md"
        />
      </Card>

      {/* Table */}
      {isLoading ? (
        <div>Loading...</div>
      ) : (
        <>
          <Card>
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-gray-50 border-b">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                      Target
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                      Tools
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                      Status
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                      Started
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                      Duration
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                      Vulns
                    </th>
                    <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-gray-200">
                  {data?.scans.map((scan: any) => (
                    <tr key={scan.id} className="hover:bg-gray-50">
                      <td className="px-6 py-4 whitespace-nowrap font-medium">
                        {scan.target}
                      </td>
                      <td className="px-6 py-4">
                        <div className="flex gap-1">
                          {scan.tools.map((tool: string) => (
                            <Badge key={tool} variant="secondary">
                              {tool}
                            </Badge>
                          ))}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <Badge className={getStatusColor(scan.status)}>
                          {scan.status}
                        </Badge>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {new Date(scan.started_at).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {scan.duration ? `${scan.duration.toFixed(0)}s` : '-'}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm">
                        {scan.vulnerabilities_found > 0 ? (
                          <span className="text-red-600 font-semibold">
                            {scan.vulnerabilities_found}
                          </span>
                        ) : (
                          '-'
                        )}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <div className="flex justify-end gap-2">
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => router.push(`/scan/${scan.id}`)}
                          >
                            <Eye className="w-4 h-4" />
                          </Button>
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => {
                              if (confirm('Delete this scan?')) {
                                deleteMutation.mutate(scan.id);
                              }
                            }}
                            disabled={scan.status === 'running'}
                          >
                            <Trash2 className="w-4 h-4 text-red-500" />
                          </Button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </Card>

          {/* Pagination */}
          <div className="mt-6 flex justify-between items-center">
            <span className="text-sm text-gray-600">
              Page {data.page} of {data.total_pages} ({data.total} total scans)
            </span>

            <div className="flex gap-2">
              <Button
                variant="outline"
                onClick={() => setPage(p => Math.max(1, p - 1))}
                disabled={page === 1}
              >
                Previous
              </Button>
              <Button
                variant="outline"
                onClick={() => setPage(p => p + 1)}
                disabled={page === data.total_pages}
              >
                Next
              </Button>
            </div>
          </div>
        </>
      )}
    </div>
  );
}
‚öôÔ∏è CONFIGURATION & ENVIRONMENT
Backend Environment Variables (.env):
bash
# app/.env
# Database
DATABASE_URL=sqlite:///./pentest.db

# Google Gemini (optional, user akan provide via header)
# GEMINI_API_KEY=your_key_here  # Not used for MVP (user provide their own)

# Application
APP_NAME=AI Pentest Agent
APP_VERSION=1.0.0
DEBUG=True
LOG_LEVEL=INFO

# Security
SECRET_KEY=your-secret-key-here-generate-with-openssl-rand-hex-32

# Rate Limiting (optional untuk future)
MAX_CONCURRENT_SCANS=5
MAX_SCANS_PER_DAY=20

# Tool Timeouts (seconds)
NMAP_TIMEOUT=600
NUCLEI_TIMEOUT=900
WHATWEB_TIMEOUT=60
SSLSCAN_TIMEOUT=120
Frontend Environment Variables (.env.local):
bash
# frontend/.env.local
NEXT_PUBLIC_API_URL=http://localhost:8000/api/v1
üöÄ DEVELOPMENT SETUP GUIDE
Prerequisites Installation:
1. Install Python 3.11+
bash
# Ubuntu/Debian
sudo apt update
sudo apt install python3.11 python3.11-venv python3-pip

# macOS (with Homebrew)
brew install python@3.11

# Windows
# Download dari python.org
2. Install Node.js 20+
bash
# Ubuntu/Debian (via NodeSource)
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt install -y nodejs

# macOS
brew install node@20

# Windows
# Download dari nodejs.org
3. Install Redis
bash
# Ubuntu/Debian
sudo apt install redis-server
sudo systemctl enable redis-server
sudo systemctl start redis-server

# macOS
brew install redis
brew services start redis

# Windows
# Download dari https://redis.io/download atau use WSL
4. Install Pentesting Tools
Nmap:

bash
# Ubuntu/Debian
sudo apt install nmap

# macOS
brew install nmap

# Windows
# Download dari https://nmap.org/download.html
Nuclei:

bash
# Install Go first (required)
# Ubuntu/Debian
sudo apt install golang-go

# macOS
brew install go

# Then install Nuclei
go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest

# Add to PATH
export PATH=$PATH:$HOME/go/bin
whatweb:

bash
# Ubuntu/Debian
sudo apt install whatweb

# macOS
brew install whatweb

# From source (all platforms)
git clone https://github.com/urbanadventurer/WhatWeb.git
cd WhatWeb
sudo make install
sslscan:

bash
# Ubuntu/Debian
sudo apt install sslscan

# macOS
brew install sslscan

# From source
git clone https://github.com/rbsec/sslscan.git
cd sslscan
make
sudo make install
Project Setup Steps:
Step 1: Create Project Structure
bash
# Create root directory
mkdir ai-pentest-agent
cd ai-pentest-agent

# Create backend folder
mkdir backend
cd backend

# Initialize Python virtual environment
python3.11 -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate  # Windows

# Create requirements.txt
cat > requirements.txt << EOF
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6
pydantic==2.5.0
pydantic-settings==2.1.0
python-dotenv==1.0.0
sqlalchemy==2.0.23
alembic==1.13.0
validators==0.22.0
google-generativeai==0.3.1
python-nmap==0.7.1
xmltodict==0.13.0
requests==2.31.0
loguru==0.7.2
EOF

# Install dependencies
pip install -r requirements.txt

# Create .env file
cp .env.example .env
# Edit .env with your values

# Initialize database
alembic init alembic
alembic revision --autogenerate -m "Initial schema"
alembic upgrade head
Step 2: Setup Frontend
bash
# Go back to root
cd ..

# Create Next.js app
npx create-next-app@latest frontend --typescript --tailwind --app --no-src-dir

cd frontend

# Install additional dependencies
npm install zustand @tanstack/react-query axios react-hook-form @hookform/resolvers zod react-markdown react-syntax-highlighter react-hot-toast lucide-react date-fns clsx

# Create .env.local
echo "NEXT_PUBLIC_API_URL=http://localhost:8000/api/v1" > .env.local
Running the Application:
Terminal 1: Backend
bash
cd backend
source venv/bin/activate

# Start FastAPI
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
Terminal 2: Frontend
bash
cd frontend

# Start Next.js dev server
npm run dev
Access Application:
Frontend: http://localhost:3000
Backend API Docs: http://localhost:8000/docs (Swagger UI)
Backend ReDoc: http://localhost:8000/redoc
üß™ TESTING GUIDE
Manual Testing Workflow:
Test 1: Basic Scan

Open http://localhost:3000
Click "Start New Scan"
Input target: scanme.nmap.org (Nmap's official test server)
Select tools: Nmap, Nuclei
Profile: Quick
Enable AI: OFF (untuk testing tool integration dulu)
Click "Start Scan"
Verify redirect ke scan detail page
Wait for scan completion (~2-3 minutes)
Verify tool results displayed
Test 2: AI Analysis

Get Gemini API key dari https://makersuite.google.com/app/apikey
Start new scan
Target: testphp.vulnweb.com (intentionally vulnerable test site)
Tools: Nmap, Nuclei
Enable AI: ON
Enter your Gemini API key
Start scan
Wait for completion (~5-7 minutes)
Verify AI analysis tab shows markdown output with vulnerabilities
Test 3: Input Validation

Try invalid targets:
127.0.0.1 (should be blocked - localhost)
192.168.1.1 (should be blocked - private IP)
invalid target (should show validation error)
example.com; ls -la (should sanitize/reject special chars)
Verify validation messages
Test 4: History & Deletion

Run 3-5 scans
Navigate to History page
Verify all scans listed
Test search by target
Delete one scan
Verify it's removed from list
üìù NEXT STEPS AFTER MVP
Phase 2: Async Processing (Week 3-4)
 Integrate Celery untuk background jobs
 Add WebSocket untuk real-time progress
 Implement scan queue management
 Better error handling & retry logic
Phase 3: Advanced Tools (Week 5-6)
 Add OWASP ZAP integration
 Add sqlmap wrapper
 Add Metasploit RPC client (optional)
 Tool orchestration: chain tools intelligently
Phase 4: Production Ready (Week 7+)
 JWT authentication
 HTTPS dengan Let's Encrypt
 Docker Compose untuk easy deployment
 Nginx reverse proxy
 Automated backups
 Monitoring & logging
üéØ SUCCESS CRITERIA MVP
‚úÖ MVP dianggap SELESAI jika:

Functional:

User bisa input target, pilih tools, start scan
Scan execute 4 tools (Nmap, Nuclei, whatweb, sslscan)
Results tersimpan di database dan tampil di UI
AI analysis works dengan Gemini API
History page tampil semua scan sebelumnya
Security:

Input validation mencegah injection
Blacklist block private IPs
API key tidak tersimpan di database
No critical vulnerabilities
User Experience:

UI responsive dan intuitive
Loading states jelas
Error messages helpful
Scan results readable (bukan raw text dump)
Code Quality:

Type hints di Python
TypeScript strict mode di Frontend
Basic error handling
README documentation
üèÅ FINAL CHECKLIST
Before Starting Development:
 All tools installed (Nmap, Nuclei, whatweb, sslscan)
 Python 3.11+ installed
 Node.js 20+ installed
 Gemini API key obtained (untuk testing)
 Project structure created
Development Milestones:
 Day 1-2: Backend setup, database models, tool wrappers
 Day 3-4: API endpoints implementation
 Day 5-6: Frontend pages (Dashboard, New Scan, Detail)
 Day 7-8: AI integration & prompt engineering
 Day 9-10: Testing, bug fixes, polish UI
 Day 11-12: Documentation, final testing, screenshot demo
 Day 13-14: Buffer untuk unexpected issues
Before Deploying to GCP:
 All MVP features tested di localhost
 No critical bugs
 Documentation complete
 Environment variables documented
 Backup strategy planned
üí™ YOU GOT THIS!
Ini adalah comprehensive blueprint untuk MVP lightweight pentest automation platform.

Key Advantages: ‚úÖ Simple: No Celery, no WebSocket, no complex auth untuk MVP ‚úÖ Fast Development: 1-2 minggu realistic timeline
‚úÖ Extensible: Easy add heavy tools later (ZAP, sqlmap)
‚úÖ Cost-Effective: $0 untuk development, ~$28/bulan untuk production
‚úÖ Secure: Paranoid tentang input validation & command injection

Your Next Action:

Install prerequisites (tools, Python, Node.js)
Setup project structure (backend + frontend folders)
Start dengan backend: Create database models
Test each tool wrapper individually
Build API endpoints one by one
Frontend bisa parallel development
Integrate everything
Test end-to-end
Extend dengan heavy tools nanti
